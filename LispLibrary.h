const char LispLibrary[] PROGMEM =
"\n"
"(defun regno (sym)\n"
"  (case sym (sp 13) (lr 14) (pc 15)\n"
"    (t (read-from-string (subseq (string sym) 1)))))\n"
"\n"
"(defun emit (bits &rest args)\n"
"  (let ((word 0) (shift -28))\n"
"    (mapc #'(lambda (value)\n"
"              (let ((width (logand (ash bits shift) #xf)))\n"
"                (incf shift 4)\n"
"                (unless (zerop (ash value (- width))) (error \"Won't fit\"))\n"
"                (setq word (logior (ash word width) value))))\n"
"          args)\n"
"    word))\n"
"\n"
"(defun offset (label) (ash (- label *pc* 4) -1))\n"
"\n"
"\n"
"(defun $word (val)\n"
"  (append\n"
"   (unless (zerop (mod *pc* 4)) (list ($nop)))\n"
"   (list (logand val #xffff) (logand (ash val -16) #xffff))))\n"
"\n"
"\n"
"\n"
"(defun lsl-lsr-0 (op immed5 argm argd)\n"
"  (emit #x41533000 0 op immed5 (regno argm) (regno argd)))\n"
"\n"
"\n"
"(defun add-sub-1 (op argd argn argm)\n"
"  (cond\n"
"   ((numberp argm)\n"
"    (emit #x61333000 #b000111 op argm (regno argn) (regno argd)))\n"
"   ((null argm)\n"
"    (emit #x61333000 #b000110 op (regno argn) (regno argd) (regno argd)))\n"
"   (t\n"
"    (emit #x61333000 #b000110 op (regno argm) (regno argn) (regno argd)))))\n"
"\n"
"\n"
"(defun mov-sub-2-3 (op2 op argd immed8)\n"
"  (emit #x41380000 op2 op (regno argd) immed8))\n"
"\n"
"\n"
"(defun add-mov-4 (op argd argm)\n"
"  (let ((rd (regno argd))\n"
"        (rm (regno argm)))\n"
"    (cond\n"
"     ((and (>= rd 8) (>= rm 8))\n"
"      (emit #x61333000 #b010001 op #b011 (- rm 8) (- rd 8)))\n"
"     ((>= rm 8)\n"
"      (emit #x61333000 #b010001 op #b001 (- rm 8) rd))\n"
"     ((>= rd 8)\n"
"      (emit #x61333000 #b010001 op #b010 rm (- rd 8))))))\n"
"\n"
"\n"
"(defun reg-reg (op argd argm)\n"
"  (emit #xa3300000 op (regno argm) (regno argd)))\n"
"\n"
"\n"
"(defun bx-blx (op argm)\n"
"  (emit #x81430000 #b01000111 op (regno argm) 0))\n"
"\n"
"\n"
"(defun str-ldr (op argd arg2)\n"
"  (cond\n"
"   ((numberp arg2)\n"
"    (when (= op 0) (error \"str not allowed with label\"))\n"
"    (let ((arg (- (truncate (+ arg2 2) 4) (truncate *pc* 4) 1)))\n"
"      (emit #x41380000 4 1 (regno argd) (max 0 arg))))\n"
"   ((listp arg2)\n"
"    (let ((argn (first arg2))\n"
"          (immed (or (eval (second arg2)) 0)))\n"
"      (unless (zerop (mod immed 4)) (error \"not multiple of 4\"))\n"
"      (cond\n"
"       ((eq (regno argn) 15)\n"
"        (when (= op 0) (error \"str not allowed with pc\"))\n"
"        (emit #x41380000 4 1 (regno argd) (truncate immed 4)))\n"
"       ((eq (regno argn) 13)\n"
"        (emit #x41380000 9 op (regno argd) (truncate immed 4)))\n"
"       (t\n"
"        (emit #x41533000 6 op (truncate immed 4) (regno argn) (regno argd))))))\n"
"   (t (error \"illegal argument\"))))\n"
"\n"
"(defun str-ldr-5 (op argd arg2)\n"
"  (cond\n"
"   ((listp arg2)\n"
"    (let ((argn (first arg2))\n"
"          (argm (second arg2)))\n"
"      (emit #x43333000 5 op (regno argm) (regno argn) (regno argd))))\n"
"   (t (error \"illegal argument\"))))\n"
"\n"
"\n"
"(defun add-10 (op argd immed8)\n"
"  (emit #x41380000 #b1010 op (regno argd) (truncate immed8 4)))\n"
"\n"
"\n"
"(defun add-sub-11 (op immed7)\n"
"  (emit #x81700000 #b11010000 op (truncate immed7 4)))\n"
"\n"
"\n"
"(defun push-pop (op lst)\n"
"  (let ((byte 0)\n"
"        (r 0))\n"
"    (mapc #'(lambda (x) \n"
"              (cond\n"
"               ((and (= op 0) (eq x 'lr)) (setq r 1))\n"
"               ((and (= op 1) (eq x 'pc)) (setq r 1))\n"
"               (t (setq byte (logior byte (ash 1 (regno x))))))) lst)\n"
"    (emit #x41218000 11 op 2 r byte)))\n"
"\n"
"\n"
"(defun b-cond-13 (cnd label)\n"
"  (let ((soff8 (logand (offset label) #xff)))\n"
"    (emit #x44800000 13 cnd soff8)))\n"
"\n"
"(defun cpside (op aif)\n"
"  (emit #xb1130000 #b10110110011 op 0 aif))\n"
"\n"
"\n"
"(defun $adc (argd argm)\n"
"  (reg-reg #b0100000101 argd argm))\n"
"\n"
"(defun $add (argd argn &optional argm)\n"
"  (cond\n"
"   ((numberp argm)\n"
"    (cond\n"
"     ((eq (regno argn) 15)\n"
"      (add-10 0 argd argm))\n"
"     ((eq (regno argn) 13)\n"
"      (add-10 1 argd argm))\n"
"     (t (add-sub-1 0 argd argn argm))))\n"
"   ((and (numberp argn) (null argm))\n"
"    (cond\n"
"     ((eq (regno argd) 13)\n"
"      (add-sub-11 0 argn))\n"
"     (t\n"
"      (mov-sub-2-3 3 0 argd argn))))\n"
"   (t\n"
"    (cond\n"
"     ((or (>= (regno argd) 8) (>= (regno argn) 8))\n"
"      (add-mov-4 0 argd argn))\n"
"     (t\n"
"      (add-sub-1 0 argd argn argm))))))\n"
"\n"
"(defun $and (argd argm)\n"
"  (reg-reg #b0100000000 argd argm))\n"
"\n"
"(defun $asr (argd argm)\n"
"  (reg-reg #b0100000100 argd argm))\n"
"\n"
"(defun $b (label)\n"
"  (emit #x41b00000 #xe 0 (logand (offset label) #x7ff)))\n"
"\n"
"(defun $bcc (label)\n"
"  (b-cond-13 3 label))\n"
"\n"
"(defun $bcs (label)\n"
"  (b-cond-13 2 label))\n"
"\n"
"(defun $beq (label)\n"
"  (b-cond-13 0 label))\n"
"\n"
"(defun $bge (label)\n"
"  (b-cond-13 10 label))\n"
"\n"
"(defun $bgt (label)\n"
"  (b-cond-13 12 label))\n"
"\n"
"(defun $bhi (label)\n"
"  (b-cond-13 8 label))\n"
"\n"
"(defun $bhs (label)\n"
"  (b-cond-13 2 label))\n"
"\n"
"(defun $ble (label)\n"
"  (b-cond-13 13 label))\n"
"\n"
"(defun $blo (label)\n"
"  (b-cond-13 3 label))\n"
"\n"
"(defun $blt (label)\n"
"  (b-cond-13 11 label))\n"
"\n"
"(defun $bmi (label)\n"
"  (b-cond-13 4 label))\n"
"\n"
"(defun $bne (label)\n"
"  (b-cond-13 1 label))\n"
"\n"
"(defun $bpl (label)\n"
"  (b-cond-13 5 label))\n"
"\n"
"(defun $bic (argd argm)\n"
"  (reg-reg #b0100001110 argd argm))\n"
"\n"
"(defun $bl (label)\n"
"  (list\n"
"   (emit #x5b000000 #b11110 (logand (ash (offset label) -11) #x7ff))\n"
"   (emit #x5b000000 #b11111 (logand (offset label) #x7ff))))\n"
"\n"
"(defun $blx (argm)\n"
"  (bx-blx 1 argm))\n"
"\n"
"(defun $bx (argm)\n"
"  (bx-blx 0 argm))\n"
"\n"
"(defun $cmn (argd argm)\n"
"  (reg-reg #b0100001011 argd argm))\n"
"\n"
"(defun $cmp (argd argm)\n"
"  (cond\n"
"   ((numberp argm)\n"
"    (mov-sub-2-3 2 1 argd argm))\n"
"   (t\n"
"    (reg-reg #b0100001010 argd argm))))\n"
"\n"
"(defun $cpsid (aif)\n"
"  (cpside 1 aif))\n"
"\n"
"(defun $cpsie (aif)\n"
"  (cpside 0 aif))\n"
"    \n"
"(defun $eor (argd argm)\n"
"  (reg-reg #b0100000001 argd argm))\n"
"\n"
"(defun $ldr (argd arg2)\n"
"  (str-ldr 1 argd arg2))\n"
"\n"
"(defun $ldrb (argd arg2)\n"
"  (str-ldr-5 6 argd arg2))\n"
"\n"
"(defun $ldrh (argd arg2)\n"
"  (str-ldr-5 5 argd arg2))\n"
"\n"
"(defun $ldrsb (argd arg2)\n"
"  (str-ldr-5 3 argd arg2))\n"
"\n"
"(defun $ldrsh (argd arg2)\n"
"  (str-ldr-5 7 argd arg2))\n"
"\n"
"(defun $lsl (argd argm &optional arg2)\n"
"  (cond\n"
"   ((numberp arg2)\n"
"    (lsl-lsr-0 0 arg2 argm argd))\n"
"   ((numberp argm)\n"
"    (lsl-lsr-0 0 argm argd argd))\n"
"   (t\n"
"    (reg-reg #b0100000010 argd argm))))\n"
"\n"
"(defun $lsr (argd argm &optional arg2)\n"
"  (cond\n"
"   ((numberp arg2)\n"
"    (lsl-lsr-0 1 arg2 argm argd))\n"
"   ((numberp argm)\n"
"    (lsl-lsr-0 1 argm argd argd))\n"
"   (t\n"
"    (reg-reg #b0100000011 argd argm))))\n"
"\n"
"(defun $mov (argd argm)\n"
"  (cond\n"
"   ((numberp argm)\n"
"    (mov-sub-2-3 2 0 argd argm))\n"
"   ((or (>= (regno argd) 8) (>= (regno argm) 8))\n"
"    (add-mov-4 1 argd argm))\n"
"   (t\n"
"    (lsl-lsr-0 0 0 argm argd))))\n"
"\n"
"(defun $mul (argd argm)\n"
"  (reg-reg #b0100001101 argd argm))\n"
"\n"
"(defun $mvn (argd argm)\n"
"  (reg-reg #b0100001111 argd argm))\n"
"\n"
"(defun $neg (argd argm)\n"
"  (reg-reg #b0100001001 argd argm))\n"
"\n"
"(defun $nop ()\n"
"  (add-mov-4 1 'r8 'r8))\n"
"\n"
"(defun $orr (argd argm)\n"
"  (reg-reg #b0100001100 argd argm))\n"
"\n"
"(defun $push (lst)\n"
"  (push-pop 0 lst))\n"
"\n"
"(defun $pop (lst)\n"
"  (push-pop 1 lst))\n"
"\n"
"(defun $rev (argd argm)\n"
"  (reg-reg #b1011101000 argd argm))\n"
"\n"
"(defun $rev16 (argd argm)\n"
"  (reg-reg #b1011101001 argd argm))\n"
"\n"
"(defun $revsh (argd argm)\n"
"  (reg-reg #b1011101010 argd argm))\n"
"\n"
"(defun $ror (argd argm)\n"
"  (reg-reg #b0100000111 argd argm))\n"
"\n"
"(defun $sbc (argd argm)\n"
"  (reg-reg #b0100000110 argd argm))\n"
"\n"
"(defun $str (argd arg2)\n"
"  (str-ldr 0 argd arg2))\n"
"\n"
"(defun $strb (argd arg2)\n"
"  (str-ldr-5 2 argd arg2))\n"
"\n"
"(defun $sub (argd argn &optional argm)\n"
"  (cond\n"
"   ((not (numberp argn))\n"
"    (add-sub-1 1 argd argn argm))\n"
"   ((eq (regno argd) 13)\n"
"      (add-sub-11 1 argn))\n"
"   (t\n"
"    (mov-sub-2-3 3 1 argd argn))))\n"
"\n"
"(defun $sxtb (argd argm)\n"
"  (reg-reg #b1011001001 argd argm))\n"
"\n"
"(defun $sxth (argd argm)\n"
"  (reg-reg #b1011001000 argd argm))\n"
"\n"
"(defun $tst (argd argm)\n"
"  (reg-reg #b0100001000 argd argm))\n"
"\n"
"(defun $uxtb (argd argm)\n"
"  (reg-reg #b1011001011 argd argm))\n"
"\n"
"(defun $uxth (argd argm)\n"
"  (reg-reg #b1011001010 argd argm))\n";
